"""Type stubs for csp Struct."""

from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    Optional,
    Set,
    Tuple,
    Type,
    TypeVar,
)

from csp.impl.types.tstype import TsType

_T = TypeVar("_T", bound="Struct")

class StructMeta(type):
    """Metaclass for Struct that handles field metadata and validation."""

    __full_metadata__: Dict[str, type]
    __full_metadata_typed__: Dict[str, Any]
    __metadata__: Dict[str, type]
    __defaults__: Dict[str, Any]
    __optional_fields__: Set[str]
    __strict_enabled__: bool

    def __new__(
        cls,
        name: str,
        bases: Tuple[type, ...],
        dct: Dict[str, Any],
        strict: bool = ...,
    ) -> "StructMeta": ...
    def layout(self, num_cols: int = ...) -> str:
        """Get memory layout of the struct."""
        ...

class Struct(metaclass=StructMeta):
    """
    Base class for csp structured data types.

    Example:
        class Quote(csp.Struct):
            bid: float
            ask: float
            size: int = 100
    """

    __full_metadata__: ClassVar[Dict[str, type]]
    __full_metadata_typed__: ClassVar[Dict[str, Any]]
    __metadata__: ClassVar[Dict[str, type]]
    __defaults__: ClassVar[Dict[str, Any]]
    __optional_fields__: ClassVar[Set[str]]
    __strict_enabled__: ClassVar[bool]

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __deepcopy__(self: _T, memo: Optional[Dict[int, Any]] = ...) -> _T: ...
    def copy(self: _T) -> _T: ...
    def deepcopy(self: _T) -> _T: ...
    def copy_from(self: _T, other: _T) -> None: ...
    def deepcopy_from(self: _T, other: _T) -> None: ...
    def update(self: _T, **kwargs: Any) -> _T: ...
    def update_from(self: _T, other: _T) -> None: ...
    def clear(self) -> None: ...
    def all_fields_set(self) -> bool: ...
    @classmethod
    def default_field_map(cls) -> Dict[str, Any]: ...
    @classmethod
    def type_adapter(cls: Type[_T]) -> Any: ...
    @classmethod
    def metadata(cls, typed: bool = ...) -> Dict[str, Any]: ...
    @classmethod
    def optional_fields(cls) -> Set[str]: ...
    @classmethod
    def is_strict(cls) -> bool: ...
    @classmethod
    def fromts(
        cls: Type[_T],
        trigger: Optional[TsType[Any]] = ...,
        /,
        **kwargs: TsType[Any],
    ) -> TsType[_T]: ...
    @classmethod
    def collectts(cls: Type[_T], **kwargs: TsType[Any]) -> TsType[_T]: ...
    @classmethod
    def from_dict(cls: Type[_T], json: Dict[str, Any], use_pydantic: bool = ...) -> _T: ...
    def to_dict(
        self,
        callback: Optional[Callable[[Any], Any]] = ...,
        preserve_enums: bool = ...,
    ) -> Dict[str, Any]: ...
    def to_dict_depr(self) -> Dict[str, Any]: ...
    def to_json(self, callback: Optional[Callable[[Any], Any]] = ...) -> str: ...
    def to_yaml(self) -> str: ...
    @classmethod
    def from_yaml(cls: Type[_T], yaml: str) -> _T: ...

def define_struct(
    name: str,
    metadata: Dict[str, type],
    defaults: Dict[str, Any] = ...,
    base: type = ...,
    strict: bool = ...,
) -> Type[Struct]: ...
