#include <csp/core/Platform.h>
#include <csp/engine/CspType.h>
#include <csp/engine/CppNode.h>
#include <csp/python/PyCppNode.h>
#include <csp/python/Conversions.h>
#include <csp/python/Conversions.h>
#include <algorithm>
#include <string>

// autogenerated
#include "mystruct.h"

namespace csp::mystruct
{

DECLARE_CPPNODE( use_struct_generic )
{
    INIT_CPPNODE( use_struct_generic ) {}

    TS_INPUT( StructPtr, x );
    TS_OUTPUT( StructPtr );

    START()
    {
        auto * structType = static_cast<const CspStructType *>( x.type() );
        m_fieldAccess = structType -> meta() -> field( "a" );
        if( !m_fieldAccess )
            CSP_THROW( TypeError, "Struct " << structType -> meta() -> name() << " has no field named " << "a" );
    }

    INVOKE()
    {
        if( m_fieldAccess -> isSet( x.lastValue().get() ) )
        {
            auto copy = x.lastValue() -> copy();
            switchCspType( m_fieldAccess -> type(), [this, &copy]( auto tag )
            {
                using ElemT = typename decltype( tag )::type;
                if( std::is_same<ElemT, int>() )
                {
                    m_fieldAccess -> setValue( copy.get(), 0 );
                }
            } );
            RETURN( copy );
        }
        RETURN( x );
    }

private:
    StructFieldPtr m_fieldAccess;
};

DECLARE_CPPNODE( use_struct_specific )
{
    INIT_CPPNODE( use_struct_specific ) {}

    // Use StructPtr like use_struct_generic for safer memory handling
    TS_INPUT( StructPtr, x );
    TS_OUTPUT( StructPtr );

    INVOKE()
    {
        // Copy the struct
        auto copy = x.lastValue() -> copy();
        // Get typed pointers (input is const, copy is mutable)
        const auto * input = static_cast<const csp::autogen::MyStruct *>( x.lastValue().get() );
        auto * myCopy = static_cast<csp::autogen::MyStruct *>( copy.get() );
        // Uppercase the b field if set
        if( input -> b_isSet() )
        {
            std::string str = input -> b();
            std::transform( str.begin(), str.end(), str.begin(), ::toupper );
            myCopy -> set_b( str );
        }
        RETURN( copy );
    }
};


EXPORT_CPPNODE( use_struct_generic );
EXPORT_CPPNODE( use_struct_specific );

}

REGISTER_CPPNODE( csp::mystruct, use_struct_generic );
REGISTER_CPPNODE( csp::mystruct, use_struct_specific );

static PyModuleDef _mystruct_module = {
    PyModuleDef_HEAD_INIT,
    "_mystruct",
    "_mystruct c++ module",
    -1,
    NULL, NULL, NULL, NULL, NULL
};

PyMODINIT_FUNC PyInit__mystruct( void )
{
    PyObject * m;

    m = PyModule_Create( &_mystruct_module );
    if( m == NULL )
        return NULL;

    if( !csp::python::InitHelper::instance().execute( m ) )
        return NULL;

    return m;
}
